-- Kerberos protocol

-- This version is a bit slow because of the complexity of message 2, but
-- is manageable

#Free variables

A, B : Agent
S: Server
ts, ta : TimeStamp
kab : SessionKey
SKey : Agent -> ServerKey

InverseKeys = (SKey,SKey), (kab,kab)

#Processes

INITIATOR(A,S) knows SKey(A)
RESPONDER(B) knows SKey(B)
SERVER(S,kab) knows SKey

#Protocol description

0.   -> A : B
--[B != A]
1. A -> S : B
2. S -> A : {ts, B, kab, {ts, kab, A}{SKey(B)} % enc}{SKey(A)}
-- Split message 3 into two
3a. A -> B : enc % {ts, kab, A}{SKey(B)}
3b. A -> B : {A, ta}{kab}
4. B -> A : {ta}{kab}

#Specification

NonInjectiveAgreement(A,B,[kab])
-- The above test succeeds, at least for this system.

Agreement(A,B,[kab])
-- The above test fails, because the intruder can simply replay messages 3
-- and 4 to make B think A is wanting a second session.

#Actual variables

TimeStamp = 0 .. 0
MaxRunTime = 0
Alice, Bob, Mallory : Agent
Sam : Server
Kab : SessionKey
InverseKeys = (Kab,Kab)

#Functions

symbolic SKey

#System

INITIATOR(Alice, Sam)
RESPONDER(Bob) ; RESPONDER(Bob)
SERVER(Sam,Kab)

#Intruder Information

Intruder = Mallory
IntruderKnowledge = {Alice, Bob, Mallory, Sam, SKey(Mallory)}
