/* CasperParser.java */
/* Generated By:JavaCC: Do not edit this line. CasperParser.java */
import model.*;
import java.util.*;
public class CasperParser implements CasperParserConstants {

    public static void main(String [] args){
        CasperParser parser;
        if(args.length == 0){
            System.out.println("CasperParser: Reading from Standard Input...");
            parser = new CasperParser(System.in);
        }
        else if(args.length == 1){
            System.out.println("CasperParser: Reading from file " + args[0] + "...");
            try{
                parser = new CasperParser(new java.io.FileInputStream(args[0]));
            }
            catch(java.io.FileNotFoundException e){
                System.out.println("CasperParser: File " + args[0] + "  not found");
                return;
            }
        }
        else{
        System.out.println("CasperParser: Usage is one of : ");
        System.out.println("\u005ct\u005ct java CasperParser < inputFile");
        System.out.println("OR");
        System.out.println("\u005ct\u005ct java CasperParser inputFile");
        return;
        }

        try{
            Protocol p = parser.script();

        }
        catch(ParseException e){
            System.out.print(e.getMessage());
        }


    }

    public static String stringify(ArrayList<String> values){
        StringBuilder builder = new StringBuilder();
        for(String str: values){
            builder.append(str);
        }
        return builder.toString();
    }

// Grammar Prod Rules

// Basic Def
  static final public 
ArrayList<String> atom() throws ParseException {Token t; ArrayList<String> atomValues = new ArrayList();
    if (jj_2_1(2)) {
      fn_app(atomValues);
{if ("" != null) return atomValues;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        t = jj_consume_token(ID);
atomValues.add(t.image);    {if ("" != null) return atomValues;}
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void fn_app(ArrayList<String> values) throws ParseException {Token t;StringBuilder tmp = new StringBuilder();
    t = jj_consume_token(ID);
tmp.append(t.image);
    t = jj_consume_token(L_PAREN);
tmp.append(t.image);
    t = jj_consume_token(ID);
tmp.append(t.image);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      t = jj_consume_token(COMMA);
tmp.append(t.image);
      t = jj_consume_token(ID);
tmp.append(t.image);
    }
    t = jj_consume_token(R_PAREN);
tmp.append(t.image); values.add(tmp.toString());
  }

  static final public ArrayList<String> msg() throws ParseException {Token t; ArrayList<String> msgValues = new ArrayList();
    cpt(msgValues);
    label_2:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_2;
      }
      t = jj_consume_token(COMMA);
msgValues.add(t.image);
      cpt(msgValues);
    }
{if ("" != null) return msgValues;}
    throw new Error("Missing return statement in function");
  }

  static final public void cpt(ArrayList<String> msgValues) throws ParseException {Token t;
    if (jj_2_3(2)) {
      t = jj_consume_token(ID);
msgValues.add(t.image);
      t = jj_consume_token(MOD);
msgValues.add(t.image);
      term(msgValues);
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:
      case L_PAREN:
      case L_BRACE:{
        term(msgValues);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MOD:{
          t = jj_consume_token(MOD);
msgValues.add(t.image);
          msgAtom(msgValues);
          break;
          }
        default:
          jj_la1[2] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void term(ArrayList<String> msgValues) throws ParseException {Token t;
    msgAtom(msgValues);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case XOR:{
      t = jj_consume_token(XOR);
msgValues.add(t.image);
      term(msgValues);
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      ;
    }
  }

  static final public void msgAtom(ArrayList<String> msgValues) throws ParseException {Token t; ArrayList<String> collector = new ArrayList(); StringBuilder tmp = new StringBuilder();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      t = jj_consume_token(ID);
msgValues.add(t.image);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case L_PAREN:{
        t = jj_consume_token(L_PAREN);
msgValues.add(t.image);
        collector = msg();
msgValues.addAll(collector);
        t = jj_consume_token(R_PAREN);
msgValues.add(t.image);
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      break;
      }
    case L_BRACE:{
      t = jj_consume_token(L_BRACE);
msgValues.add(t.image);
      collector = msg();
msgValues.addAll(collector);
      t = jj_consume_token(R_BRACE);
msgValues.add(t.image);
      t = jj_consume_token(L_BRACE);
msgValues.add(t.image);
      cpt(msgValues);
      t = jj_consume_token(R_BRACE);
msgValues.add(t.image);
      break;
      }
    case L_PAREN:{
      t = jj_consume_token(L_PAREN);
msgValues.add(t.image);
      collector = msg();
msgValues.addAll(collector);
      t = jj_consume_token(R_PAREN);
msgValues.add(t.image);
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public Token type_name() throws ParseException {Token t;
    t = jj_consume_token(ID);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public Token process_name() throws ParseException {Token t;
    t = jj_consume_token(ID);
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public Protocol script() throws ParseException {Protocol p = new Protocol(); Intruder i; ArrayList<Message> msgs = new ArrayList();
    free_vars();
    processes();
    msgs = prot_desc();
    spec_section();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQ:{
      equivalences();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    actual_vars();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FUNCS:{
      functions();
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    system();
    i = intruder();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CHANNELS:{
      channels();
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    jj_consume_token(0);
p.setIntruder(i);  p.setMessages(msgs);   {if ("" != null) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public void free_vars() throws ParseException {
    jj_consume_token(FREE_VARS);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INVERSE_KEYS:
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        var_dec();
        break;
        }
      case INVERSE_KEYS:{
        inv_keys_dec();
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void var_dec() throws ParseException {
    jj_consume_token(ID);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      type_expr();
      break;
      }
    case TIMESTAMP:{
      jj_consume_token(TIMESTAMP);
      break;
      }
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_SQUARE:{
      subtype_expr();
      break;
      }
    default:
      jj_la1[14] = jj_gen;
      ;
    }
  }

  static final public void subtype_expr() throws ParseException {
    jj_consume_token(L_SQUARE);
    jj_consume_token(ID);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(R_SQUARE);
  }

  static final public void type_expr() throws ParseException {
    type_name();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case X:
    case ARROW:{
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case X:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_6;
        }
        jj_consume_token(X);
        type_name();
      }
      jj_consume_token(ARROW);
      type_name();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
  }

  static final public void inv_keys_dec() throws ParseException {
    jj_consume_token(INVERSE_KEYS);
    inv_key_pair();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      inv_key_pair();
    }
  }

  static final public void inv_key_pair() throws ParseException {
    jj_consume_token(L_PAREN);
    jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(ID);
    jj_consume_token(R_PAREN);
  }

  static final public void processes() throws ParseException {
    jj_consume_token(PROCESSES);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        break label_8;
      }
      process_def();
    }
  }

  static final public void process_def() throws ParseException {Token t;
    process_name();
    jj_consume_token(L_PAREN);
    jj_consume_token(ID);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        break label_9;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(R_PAREN);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case KNOWS:{
      knows_stmt();
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GENERATES:{
      gen_stmt();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      ;
    }
  }

  static final public void knows_stmt() throws ParseException {
    jj_consume_token(KNOWS);
    atom();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        break label_10;
      }
      jj_consume_token(COMMA);
      atom();
    }
  }

  static final public void gen_stmt() throws ParseException {
    jj_consume_token(GENERATES);
    jj_consume_token(ID);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        break label_11;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
  }

  static final public ArrayList<Message> prot_desc() throws ParseException {Message message = new Message(); ArrayList<Message> msglist = new ArrayList();
    jj_consume_token(PROT_DESC);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LINE_NO:
      case LESS_THAN:{
        ;
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        break label_12;
      }
      if (jj_2_4(3)) {
        message = prot_msg();
msglist.add(message);
      } else if (jj_2_5(3)) {
        message = env_msg_send();
msglist.add(message);
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LINE_NO:
        case LESS_THAN:{
          message = env_msg_rec();
msglist.add(message);
          break;
          }
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
{if ("" != null) return msglist;}
    throw new Error("Missing return statement in function");
  }

  static final public Message prot_msg() throws ParseException {Token t; Message message = new Message(); ArrayList<String> msgValues = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LESS_THAN:{
      assignment_line();
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(LINE_NO);
    jj_consume_token(DOT);
    t = jj_consume_token(ID);
message.setSenderId(t.image);
    jj_consume_token(ARROW);
    t = jj_consume_token(ID);
message.setReceiverId(t.image);
    jj_consume_token(COLON);
    msgValues = msg();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_SQUARE:{
      test_line();
      break;
      }
    default:
      jj_la1[28] = jj_gen;
      ;
    }
message.setMsgString(stringify(msgValues));    {if ("" != null) return message;}
    throw new Error("Missing return statement in function");
  }

  static final public void assignment_line() throws ParseException {
    jj_consume_token(LESS_THAN);
    assignment();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMI_COLON:{
        ;
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        break label_13;
      }
      jj_consume_token(SEMI_COLON);
      assignment();
    }
    jj_consume_token(GREATER_THAN);
  }

  static final public void assignment() throws ParseException {
    jj_consume_token(ID);
    jj_consume_token(ASSIGNMENT);
    fdr_expr();
  }

  static final public void test_line() throws ParseException {
    jj_consume_token(L_SQUARE);
    test();
    jj_consume_token(R_SQUARE);
  }

  static final public void test() throws ParseException {
    fdr_expr();
  }

  static final public void fdr_expr() throws ParseException {
    label_14:
    while (true) {
      jj_consume_token(LETTER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LETTER:{
        ;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        break label_14;
      }
    }
    jj_consume_token(NOT_EQUAL);
    label_15:
    while (true) {
      jj_consume_token(LETTER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LETTER:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_15;
      }
    }
  }

  static final public Message env_msg_send() throws ParseException {Token t; Message message = new Message(); ArrayList<String> msgValues = new ArrayList();
    jj_consume_token(LINE_NO);
    jj_consume_token(DOT);
    jj_consume_token(ARROW);
    t = jj_consume_token(ID);
message.setReceiverId(t.image);
    jj_consume_token(COLON);
    msgValues = msg();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_SQUARE:{
      test_line();
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      ;
    }
message.setMsgString(stringify(msgValues)); {if ("" != null) return message;}
    throw new Error("Missing return statement in function");
  }

  static final public Message env_msg_rec() throws ParseException {Token t; Message message = new Message(); ArrayList<String> msgValues = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LESS_THAN:{
      assignment_line();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(LINE_NO);
    jj_consume_token(DOT);
    t = jj_consume_token(ID);
message.setSenderId(t.image);
    jj_consume_token(ARROW);
    jj_consume_token(COLON);
    msgValues = msg();
message.setMsgString(stringify(msgValues)); {if ("" != null) return message;}
    throw new Error("Missing return statement in function");
  }

  static final public void spec_section() throws ParseException {
    jj_consume_token(SPEC);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SECRET:
      case STRONG_SECRET:
      case AGREEMENT:
      case N_I_AGREEMENT:
      case WEAK_AGREEMENT:
      case ALIVENESS:
      case TIMED_AGREEMENT:
      case TIMED_N_I_AGREEMENT:
      case TIMED_WEAK_AGREEMENT:
      case TIMED_ALIVENESS:
      case IF:{
        ;
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SECRET:
      case STRONG_SECRET:
      case AGREEMENT:
      case N_I_AGREEMENT:
      case WEAK_AGREEMENT:
      case ALIVENESS:
      case TIMED_AGREEMENT:
      case TIMED_N_I_AGREEMENT:
      case TIMED_WEAK_AGREEMENT:
      case TIMED_ALIVENESS:{
        spec();
        break;
        }
      case IF:{
        temporal_spec();
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void spec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SECRET:{
      jj_consume_token(SECRET);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      atom();
      jj_consume_token(COMMA);
      agents();
      jj_consume_token(R_PAREN);
      break;
      }
    case STRONG_SECRET:{
      jj_consume_token(STRONG_SECRET);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      atom();
      jj_consume_token(COMMA);
      agents();
      jj_consume_token(R_PAREN);
      break;
      }
    case AGREEMENT:{
      jj_consume_token(AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      fields();
      jj_consume_token(R_PAREN);
      break;
      }
    case N_I_AGREEMENT:{
      jj_consume_token(N_I_AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      fields();
      jj_consume_token(R_PAREN);
      break;
      }
    case WEAK_AGREEMENT:{
      jj_consume_token(WEAK_AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(R_PAREN);
      break;
      }
    case ALIVENESS:{
      jj_consume_token(ALIVENESS);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(R_PAREN);
      break;
      }
    case TIMED_AGREEMENT:{
      jj_consume_token(TIMED_AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      time();
      jj_consume_token(COMMA);
      fields();
      jj_consume_token(R_PAREN);
      break;
      }
    case TIMED_N_I_AGREEMENT:{
      jj_consume_token(TIMED_N_I_AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      time();
      jj_consume_token(COMMA);
      fields();
      jj_consume_token(R_PAREN);
      break;
      }
    case TIMED_WEAK_AGREEMENT:{
      jj_consume_token(TIMED_WEAK_AGREEMENT);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      time();
      jj_consume_token(R_PAREN);
      break;
      }
    case TIMED_ALIVENESS:{
      jj_consume_token(TIMED_ALIVENESS);
      jj_consume_token(L_PAREN);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      jj_consume_token(ID);
      jj_consume_token(COMMA);
      time();
      jj_consume_token(R_PAREN);
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void agents() throws ParseException {
    jj_consume_token(L_SQUARE);
    jj_consume_token(ID);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(R_SQUARE);
  }

  static final public void fields() throws ParseException {
    jj_consume_token(L_SQUARE);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      jj_consume_token(ID);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          break label_18;
        }
        jj_consume_token(COMMA);
        jj_consume_token(ID);
      }
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    jj_consume_token(R_SQUARE);
  }

// TODO Change to N
  static final public void time() throws ParseException {
    jj_consume_token(DIGIT);
  }

  static final public void temporal_spec() throws ParseException {
    jj_consume_token(IF);
    temporal_formula();
    jj_consume_token(THEN);
    temporal_formula();
  }

  static final public void temporal_formula() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_PAREN:{
      jj_consume_token(L_PAREN);
      temporal_formula();
      jj_consume_token(R_PAREN);
      temporal_formulaP();
      break;
      }
    case ID:{
      temporal_event();
      temporal_formulaP();
      break;
      }
    case PREV:{
      jj_consume_token(PREV);
      temporal_formula();
      temporal_formulaP();
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void temporal_formulaP() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AND:{
      jj_consume_token(AND);
      temporal_formula();
      temporal_formulaP();
      break;
      }
    case OR:{
      jj_consume_token(OR);
      temporal_formula();
      temporal_formulaP();
      break;
      }
    default:
      jj_la1[41] = jj_gen;

    }
  }

  static final public void temporal_event() throws ParseException {
    jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SENDS:{
      jj_consume_token(SENDS);
      break;
      }
    case RECEIVES:{
      jj_consume_token(RECEIVES);
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(MESSAGE);
    jj_consume_token(LINE_NO);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FROM:
    case TO:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FROM:{
        jj_consume_token(FROM);
        break;
        }
      case TO:{
        jj_consume_token(TO);
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(ID);
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CONTAINING:{
      jj_consume_token(CONTAINING);
      sub();
      jj_consume_token(COMMA);
      sub();
      break;
      }
    default:
      jj_la1[45] = jj_gen;
      ;
    }
  }

  static final public void sub() throws ParseException {
    jj_consume_token(ID);
    subP();
  }

  static final public void subP() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FOR:{
      jj_consume_token(FOR);
      jj_consume_token(ID);
      break;
      }
    default:
      jj_la1[46] = jj_gen;

    }
  }

  static final public void equivalences() throws ParseException {
    jj_consume_token(EQ);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FOR_ALL:{
        ;
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        break label_19;
      }
      equiv_dec();
    }
  }

  static final public void equiv_dec() throws ParseException {
    jj_consume_token(FOR_ALL);
    quants();
    jj_consume_token(DOT);
    msg();
    jj_consume_token(EQUALS);
    msg();
  }

  static final public void quants() throws ParseException {
    quant();
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[48] = jj_gen;
        break label_20;
      }
      jj_consume_token(COMMA);
      quant();
    }
  }

  static final public void quant() throws ParseException {
    jj_consume_token(ID);
    label_21:
    while (true) {
      if (jj_2_6(2)) {
        ;
      } else {
        break label_21;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLON:{
      jj_consume_token(COLON);
      type_name();
      break;
      }
    default:
      jj_la1[49] = jj_gen;
      ;
    }
  }

  static final public void actual_vars() throws ParseException {
    jj_consume_token(ACTUAL_VARS);
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INVERSE_KEYS:
      case TIMESTAMP:
      case MAX_RUN_TIME:
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        break label_22;
      }
      act_dec();
    }
  }

  static final public void act_dec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      act_var_dec();
      break;
      }
    case TIMESTAMP:{
      timestamp_def();
      break;
      }
    case MAX_RUN_TIME:{
      maxruntime_def();
      break;
      }
    case INVERSE_KEYS:{
      act_inv_keys_dec();
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void act_var_dec() throws ParseException {
    jj_consume_token(ID);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        break label_23;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(COLON);
    type_name();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTERNAL:
    case INTERNAL_KNOWN:
    case INTERNAL_UNKNOWN:{
      di_tag();
      break;
      }
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_SQUARE:{
      subtype_expr();
      break;
      }
    default:
      jj_la1[54] = jj_gen;
      ;
    }
  }

  static final public void di_tag() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTERNAL:{
      jj_consume_token(EXTERNAL);
      break;
      }
    case INTERNAL_KNOWN:{
      jj_consume_token(INTERNAL_KNOWN);
      break;
      }
    case INTERNAL_UNKNOWN:{
      jj_consume_token(INTERNAL_UNKNOWN);
      break;
      }
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void timestamp_def() throws ParseException {
    jj_consume_token(TIMESTAMP);
    jj_consume_token(EQUALS);
    time();
    jj_consume_token(TWO_DOTS);
    time();
  }

  static final public void maxruntime_def() throws ParseException {
    jj_consume_token(MAX_RUN_TIME);
    jj_consume_token(EQUALS);
    time();
  }

  static final public void act_inv_keys_dec() throws ParseException {
    jj_consume_token(INVERSE_KEYS);
    act_inv_key_pair();
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        break label_24;
      }
      jj_consume_token(COMMA);
      act_inv_key_pair();
    }
  }

  static final public void act_inv_key_pair() throws ParseException {
    jj_consume_token(L_PAREN);
    jj_consume_token(ID);
    jj_consume_token(COMMA);
    jj_consume_token(ID);
    jj_consume_token(R_PAREN);
  }

  static final public void functions() throws ParseException {
    jj_consume_token(FUNCS);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SYMBOLIC:
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[57] = jj_gen;
        break label_25;
      }
      functions_line();
    }
  }

  static final public void functions_line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      explicit_function_line();
      break;
      }
    case SYMBOLIC:{
      symbolic_line();
      break;
      }
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void explicit_function_line() throws ParseException {
    fn_def_lhs();
    jj_consume_token(EQUALS);
    jj_consume_token(ID);
  }

  static final public void fn_def_lhs() throws ParseException {
    jj_consume_token(ID);
    jj_consume_token(L_PAREN);
    fn_def_arg();
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        break label_26;
      }
      jj_consume_token(COMMA);
      fn_def_arg();
    }
    jj_consume_token(R_PAREN);
  }

  static final public void fn_def_arg() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      jj_consume_token(ID);
      break;
      }
    case UNDERSCORE:{
      jj_consume_token(UNDERSCORE);
      break;
      }
    default:
      jj_la1[60] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void symbolic_line() throws ParseException {
    jj_consume_token(SYMBOLIC);
    jj_consume_token(ID);
    label_27:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[61] = jj_gen;
        break label_27;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
  }

  static final public void system() throws ParseException {
    jj_consume_token(SYSTEM);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        ;
        break;
        }
      default:
        jj_la1[62] = jj_gen;
        break label_28;
      }
      agent_dec();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WITHDRAW_OPTION:{
      withdraw_dec();
      break;
      }
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GEN_SYS:
    case GEN_SYS_F_R_S:{
      generate_system();
      break;
      }
    default:
      jj_la1[64] = jj_gen;
      ;
    }
  }

  static final public void agent_dec() throws ParseException {
    instance_dec();
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SEMI_COLON:{
        ;
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        break label_29;
      }
      jj_consume_token(SEMI_COLON);
      instance_dec();
    }
  }

  static final public void instance_dec() throws ParseException {
    process_name();
    jj_consume_token(L_PAREN);
    jj_consume_token(ID);
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[66] = jj_gen;
        break label_30;
      }
      jj_consume_token(COMMA);
      jj_consume_token(ID);
    }
    jj_consume_token(R_PAREN);
  }

  static final public void withdraw_dec() throws ParseException {
    jj_consume_token(WITHDRAW_OPTION);
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      jj_consume_token(TRUE);
      break;
      }
    case FALSE:{
      jj_consume_token(FALSE);
      break;
      }
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void generate_system() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GEN_SYS:{
      jj_consume_token(GEN_SYS);
      break;
      }
    case GEN_SYS_F_R_S:{
      jj_consume_token(GEN_SYS_F_R_S);
      jj_consume_token(LINE_NO);
      jj_consume_token(TO);
      jj_consume_token(LINE_NO);
      break;
      }
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public Intruder intruder() throws ParseException {Token t; Token t1;
    Intruder intruder = new Intruder();
    ArrayList<String> intruderKnowledge = new ArrayList();
    ArrayList<String> collector = new ArrayList();
    jj_consume_token(INTRUDER_INFO);
    jj_consume_token(INTRUDER);
    jj_consume_token(EQUALS);
    t = jj_consume_token(ID);
intruder.setId(t.image);
    jj_consume_token(INTRUDER_KNOWLEDGE);
    jj_consume_token(EQUALS);
    jj_consume_token(L_BRACE);
    collector = atom();
intruderKnowledge.addAll(collector);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[69] = jj_gen;
        break label_31;
      }
      jj_consume_token(COMMA);
      collector = atom();
intruderKnowledge.addAll(collector);
    }
    jj_consume_token(R_BRACE);
intruder.setKnowledge(intruderKnowledge);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTRUDER_PROCESSES:{
      internal_proc_dec();
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STALE_KNOWLEDGE:{
      t1 = stale_knowledge_dec();
if(t.image.equals("true")) intruder.setStaleKnowledge(true);
      break;
      }
    default:
      jj_la1[71] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CRACKABLE:{
      crackable_dec();
      break;
      }
    default:
      jj_la1[72] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GUESSABLE:{
      guessable_dec();
      break;
      }
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNBOUND_P:{
      jj_consume_token(UNBOUND_P);
      break;
      }
    default:
      jj_la1[74] = jj_gen;
      ;
    }
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FOR_ALL:{
        ;
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        break label_32;
      }
      deduction();
    }
{if ("" != null) return intruder;}
    throw new Error("Missing return statement in function");
  }

  static final public void deduction() throws ParseException {
    jj_consume_token(FOR_ALL);
    quants();
    jj_consume_token(DOT);
    msg();
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[76] = jj_gen;
        break label_33;
      }
      jj_consume_token(COMMA);
      msg();
    }
    jj_consume_token(PIPE_DASH);
    msg();
  }

  static final public void internal_proc_dec() throws ParseException {
    jj_consume_token(INTRUDER_PROCESSES);
    jj_consume_token(EQUALS);
    process_name();
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[77] = jj_gen;
        break label_34;
      }
      jj_consume_token(COMMA);
      process_name();
    }
  }

  static final public Token stale_knowledge_dec() throws ParseException {Token t;
    jj_consume_token(STALE_KNOWLEDGE);
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      t = jj_consume_token(TRUE);
      break;
      }
    case FALSE:{
      t = jj_consume_token(FALSE);
      break;
      }
    default:
      jj_la1[78] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public void crackable_dec() throws ParseException {
    jj_consume_token(CRACKABLE);
    jj_consume_token(EQUALS);
    crackable_type();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[79] = jj_gen;
        break label_35;
      }
      jj_consume_token(COMMA);
      crackable_type();
    }
  }

  static final public void crackable_type() throws ParseException {
    type_name();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_PAREN:{
      jj_consume_token(L_PAREN);
      time();
      jj_consume_token(R_PAREN);
      break;
      }
    default:
      jj_la1[80] = jj_gen;
      ;
    }
  }

  static final public void guessable_dec() throws ParseException {
    jj_consume_token(GUESSABLE);
    jj_consume_token(EQUALS);
    type_name();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[81] = jj_gen;
        break label_36;
      }
      jj_consume_token(COMMA);
      type_name();
    }
  }

  static final public void channels() throws ParseException {
    jj_consume_token(CHANNELS);
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SECRET:
      case AUTH:
      case DIRECT:
      case SESSION:
      case STREAM:
      case LINE_NO:{
        ;
        break;
        }
      default:
        jj_la1[82] = jj_gen;
        break label_37;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SECRET:
      case AUTH:
      case DIRECT:{
        old_channel_spec();
        break;
        }
      case SESSION:
      case STREAM:
      case LINE_NO:{
        channel_spec();
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void old_channel_spec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AUTH:{
      jj_consume_token(AUTH);
      break;
      }
    case SECRET:{
      jj_consume_token(SECRET);
      break;
      }
    case DIRECT:{
      jj_consume_token(DIRECT);
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void channel_spec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LINE_NO:{
      msg_channel_spec();
      break;
      }
    case SESSION:
    case STREAM:{
      session_channel_spec();
      break;
      }
    default:
      jj_la1[85] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void msg_channel_spec() throws ParseException {
    jj_consume_token(LINE_NO);
    msg_channel_prop();
  }

  static final public void msg_channel_prop() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case C:{
      jj_consume_token(C);
      break;
      }
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NF:{
      jj_consume_token(NF);
      break;
      }
    default:
      jj_la1[87] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NRA:
    case NRA_MINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NRA:{
        jj_consume_token(NRA);
        break;
        }
      case NRA_MINUS:{
        jj_consume_token(NRA_MINUS);
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NR:
    case NR_MINUS:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NR:{
        jj_consume_token(NR);
        break;
        }
      case NR_MINUS:{
        jj_consume_token(NR_MINUS);
        break;
        }
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[91] = jj_gen;
      ;
    }
  }

  static final public void session_channel_spec() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SESSION:{
      jj_consume_token(SESSION);
      break;
      }
    case STREAM:{
      jj_consume_token(STREAM);
      break;
      }
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INJECTIVE:
    case SYMMETRIC:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INJECTIVE:{
        jj_consume_token(INJECTIVE);
        break;
        }
      case SYMMETRIC:{
        jj_consume_token(SYMMETRIC);
        break;
        }
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
      }
    default:
      jj_la1[94] = jj_gen;
      ;
    }
    jj_consume_token(LINE_NO);
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[95] = jj_gen;
        break label_38;
      }
      jj_consume_token(COMMA);
      jj_consume_token(LINE_NO);
    }
  }

  static private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_3R_51()
 {
    if (jj_scan_token(L_PAREN)) return true;
    return false;
  }

  static private boolean jj_3R_50()
 {
    if (jj_scan_token(L_BRACE)) return true;
    return false;
  }

  static private boolean jj_3R_47()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_49()
 {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3_2()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_40()) return true;
    return false;
  }

  static private boolean jj_3R_43()
 {
    if (jj_3R_45()) return true;
    return false;
  }

  static private boolean jj_3R_45()
 {
    if (jj_3R_47()) return true;
    return false;
  }

  static private boolean jj_3R_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) return true;
    }
    return false;
  }

  static private boolean jj_3_3()
 {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(MOD)) return true;
    return false;
  }

  static private boolean jj_3R_48()
 {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(ASSIGNMENT)) return true;
    return false;
  }

  static private boolean jj_3_4()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  static private boolean jj_3R_46()
 {
    if (jj_scan_token(LESS_THAN)) return true;
    if (jj_3R_48()) return true;
    return false;
  }

  static private boolean jj_3R_44()
 {
    if (jj_3R_46()) return true;
    return false;
  }

  static private boolean jj_3R_41()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) jj_scanpos = xsp;
    if (jj_scan_token(LINE_NO)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3_5()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  static private boolean jj_3R_39()
 {
    if (jj_scan_token(ID)) return true;
    if (jj_scan_token(L_PAREN)) return true;
    return false;
  }

  static private boolean jj_3_1()
 {
    if (jj_3R_39()) return true;
    return false;
  }

  static private boolean jj_3R_42()
 {
    if (jj_scan_token(LINE_NO)) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  static private boolean jj_3_6()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public CasperParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[96];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ffc000,0x1ffc000,0xffc000,0x0,0x0,0x0,0x10000000,0xc000000,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x1000,0x10000000,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x4,0x8,0x20,0x0,0x0,0xc00,0xc00,0x0,0x380,0x0,0x380,0x0,0x2000,0x2000,0x0,0x0,0x0,0x0,0x8000,0xc0000,0x0,0x0,0x30000,0xc0000,0x0,0x800000,0x2000000,0x4000000,0x8000000,0x1000000,0x20,0x0,0x0,0x30000,0x0,0x0,0x0,0xa0000000,0xa0000000,0xa0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x100000,0x0,0x2000000,0xa0100000,0x800000,0x20000000,0xa0100000,0x0,0x0,0x0,0x100000,0x100000,0x0,0x100000,0x0,0x0,0x40000,0x1040000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x20100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x0,0x0,0x0,0x0,0x100000,0x100000,0x0,0x100000,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x800c0,0x800c0,0x0,0x800c0,0x1,0x2,0xc,0xc,0x30,0x30,0xc0,0x300,0x300,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x2,0x20,0x0,0x0,0x20,0x0,0x20,0x0,0x0,0x20,0x20,0x8,0x8,0x8,0x2,0x40,0x0,0x0,0x2,0x8,0x0,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x80,0x0,0x0,0x20,0x0,0x2,0x0,0x20,0x0,0x0,0x20,0x800,0x20,0x0,0x0,0x0,0x40,0x20,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x20,0x0,0x20,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[6];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public CasperParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public CasperParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CasperParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public CasperParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CasperParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public CasperParser(CasperParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(CasperParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 96; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[109];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 96; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 109; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 6; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
